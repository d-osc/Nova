Token #1 pos=0 char='c' (ASCII 99)
Token #2 pos=6 char='o' (ASCII 111)
Token #3 pos=10 char='=' (ASCII 61)
Token #4 pos=12 char='{' (ASCII 123)
Token #5 pos=14 char='a' (ASCII 97)
Token #6 pos=15 char=':' (ASCII 58)
Token #7 pos=17 char='1' (ASCII 49)
Token #8 pos=18 char=',' (ASCII 44)
Token #9 pos=20 char='b' (ASCII 98)
Token #10 pos=21 char=':' (ASCII 58)
Token #11 pos=23 char='2' (ASCII 50)
Token #12 pos=25 char='}' (ASCII 125)
Token #13 pos=26 char=';' (ASCII 59)
Token #14 pos=28 char='c' (ASCII 99)
Token #15 pos=35 char='.' (ASCII 46)
Token #16 pos=36 char='l' (ASCII 108)
Token #17 pos=39 char='(' (ASCII 40)
Token #18 pos=40 char='"' (ASCII 34)
Token #19 pos=47 char=',' (ASCII 44)
Token #20 pos=49 char='o' (ASCII 111)
Token #21 pos=52 char='.' (ASCII 46)
Token #22 pos=53 char='a' (ASCII 97)
Token #23 pos=54 char=',' (ASCII 44)
Token #24 pos=56 char='o' (ASCII 111)
Token #25 pos=59 char='.' (ASCII 46)
Token #26 pos=60 char='b' (ASCII 98)
Token #27 pos=61 char=')' (ASCII 41)
Token #28 pos=62 char=';' (ASCII 59)

=== TRACE: ObjectExpr processing, ID=__obj_0 ===
  TRACE: Property 'a' is a data field
  TRACE: Property 'b' is a data field
  TRACE: Creating struct type '__obj_0' with 2 data fields
DEBUG HIRGen: Detected console.log() call with 3 arguments
DEBUG HIRGen: console.log arg 0: type=17
DEBUG HIRGen: Selected runtime function: nova_console_log_string (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_string

=== TRACE: MemberExpr property access ===
  Property name: 'a'
  object pointer: 0000022CE1A88100
  currentThis_ pointer: 0000000000000000
  object == currentThis_: NO
  currentClassStructType_: 0000000000000000
  TRACE: Extracting struct type from object->type
  TRACE: object->type pointer: 0000022CE1A6E5B0
  TRACE: object->type->kind = 18
  TRACE: Object type is NOT directly a Struct, trying Pointer
  TRACE: HIRPointerType cast result: 0000022CE1A6E5B0
  TRACE: Successfully cast to HIRPointerType
  TRACE: Pointee type exists, kind=22
  TRACE: Pointee is a struct!
  TRACE: Struct name: __obj_0
  TRACE: Struct has 2 fields:
    [0] a (kind=6)
    [1] b (kind=6)

  TRACE: Searching for field 'a' in struct...
  TRACE: structType is valid, searching 2 fields
    Checking field[0]: 'a'
  TRACE SUCCESS: Found field 'a' at index 0

  TRACE: Creating GetField operation
    object pointer: 0000022CE1A88100
    field index: 0
    field name: 'a'
  DEBUG GetField: Found field type from pointer-to-struct, type=6
    Result lastValue_: 0000022CE1A88180
    Result type kind: 6
=== END TRACE ===
DEBUG HIRGen: console.log arg 1: type=6
DEBUG HIRGen: Selected runtime function: nova_console_log_number (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_number

=== TRACE: MemberExpr property access ===
  Property name: 'b'
  object pointer: 0000022CE1A88700
  currentThis_ pointer: 0000000000000000
  object == currentThis_: NO
  currentClassStructType_: 0000000000000000
  TRACE: Extracting struct type from object->type
  TRACE: object->type pointer: 0000022CE1A6E5B0
  TRACE: object->type->kind = 18
  TRACE: Object type is NOT directly a Struct, trying Pointer
  TRACE: HIRPointerType cast result: 0000022CE1A6E5B0
  TRACE: Successfully cast to HIRPointerType
  TRACE: Pointee type exists, kind=22
  TRACE: Pointee is a struct!
  TRACE: Struct name: __obj_0
  TRACE: Struct has 2 fields:
    [0] a (kind=6)
    [1] b (kind=6)

  TRACE: Searching for field 'b' in struct...
  TRACE: structType is valid, searching 2 fields
    Checking field[0]: 'a'
    Checking field[1]: 'b'
  TRACE SUCCESS: Found field 'b' at index 1

  TRACE: Creating GetField operation
    object pointer: 0000022CE1A88700
    field index: 1
    field name: 'b'
  DEBUG GetField: Found field type from pointer-to-struct, type=6
    Result lastValue_: 0000022CE1A88480
    Result type kind: 6
=== END TRACE ===
DEBUG HIRGen: console.log arg 2: type=6
DEBUG HIRGen: Selected runtime function: nova_console_log_number (needsLoad=0)
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88D00) with 2 operands
  Function: nova_console_log_string
  Operand 0: value present (ptr=0000022CE1A85350)
DEBUG MIRGen: Translating string constant: nova_console_log_string
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Translating string constant: Both:
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: GetField dest type = 5
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88400) with 1 operands
  Function: nova_console_print_space
DEBUG MIRGen: Translating string constant: nova_console_print_space
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88B00) with 2 operands
  Function: nova_console_log_number
  Operand 0: value present (ptr=0000022CE1A88180)
DEBUG MIRGen: Translating string constant: nova_console_log_number
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: GetField dest type = 5
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88580) with 1 operands
  Function: nova_console_print_space
DEBUG MIRGen: Translating string constant: nova_console_print_space
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88800) with 2 operands
  Function: nova_console_log_number
  Operand 0: value present (ptr=0000022CE1A88480)
DEBUG MIRGen: Translating string constant: nova_console_log_number
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=0000022CE1A88C00) with 1 operands
  Function: nova_console_print_newline
DEBUG MIRGen: Translating string constant: nova_console_print_newline
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing return statement in function '__nova_main'
DEBUG MIRGen: Return value cast to constant: SUCCESS

========== MIR DUMP ==========
// MIR Module: main

fn __nova_main() -> i32 {
    // Local declarations
    let mut ___obj_0.0: *const // __obj_0.0;
    let mut _obj.1: *const // obj.1;
    let mut _console_result.2: () // console_result.2;
    let mut _obj.3: *const // obj.3;
    let mut _a.4: i64 // a.4;
    let mut _space.5: () // space.5;
    let mut _console_result.6: () // console_result.6;
    let mut _obj.7: *const // obj.7;
    let mut _b.8: i64 // b.8;
    let mut _space.9: () // space.9;
    let mut _console_result.10: () // console_result.10;
    let mut _console_newline.11: () // console_newline.11;

    bb0:
    StorageLive(___obj_0.0);
    ___obj_0.0 = Aggregate(Struct, [const 1, const 2]);
    StorageLive(_obj.1);
    StorageLive(_obj.1);
    _obj.1 = Use(copy ___obj_0.0);
    StorageLive(_console_result.2);
    _console_result.2 = call const "nova_console_log_string"(const "Both:") -> [return: call_cont];

    call_cont:
    StorageLive(_obj.3);
    _obj.3 = Use(copy _obj.1);
    StorageLive(_a.4);
    _a.4 = GetElement(copy _obj.3, const 0);
    StorageLive(_space.5);
    _space.5 = call const "nova_console_print_space"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.6);
    _console_result.6 = call const "nova_console_log_number"(copy _a.4) -> [return: call_cont];

    call_cont:
    StorageLive(_obj.7);
    _obj.7 = Use(copy _obj.1);
    StorageLive(_b.8);
    _b.8 = GetElement(copy _obj.7, const 1);
    StorageLive(_space.9);
    _space.9 = call const "nova_console_print_space"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.10);
    _console_result.10 = call const "nova_console_log_number"(copy _b.8) -> [return: call_cont];

    call_cont:
    StorageLive(_console_newline.11);
    _console_newline.11 = call const "nova_console_print_newline"() -> [return: call_cont];

    call_cont:
    _0 = Use(const 0);
    return;

}

========== END MIR DUMP ==========

DEBUG LLVM: Disabling constant folding to preserve runtime comparisons
DEBUG LLVM: First pass - creating function declarations
DEBUG LLVM: Declared function: __nova_main
DEBUG LLVM: Second pass - generating function bodies
DEBUG LLVM: Starting generateFunction for: __nova_main
DEBUG LLVM: Cleared per-function context maps
DEBUG LLVM: Created struct type struct.NovaObject with ObjectHeader + 8 fields
DEBUG LLVM: Using existing declaration for function: __nova_main
DEBUG LLVM: Creating alloca for variables to prevent constant folding
DEBUG LLVM: Function has 7 basic blocks
DEBUG LLVM: Processing block 0 with 6 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A7EE70
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 0000022CE1A7EE70
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A7EE70
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=1
DEBUG LLVM: Checking statement 4 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A899B0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 0000022CE1A899B0
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A899B0
DEBUG LLVM: Checking statement 5 kind=1
DEBUG LLVM: Found Call terminator in block 0
DEBUG LLVM: Call has destination place=0000022CE1A8A220
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A8A220
DEBUG LLVM: Finished processing block 0
DEBUG LLVM: Processing block 1 with 5 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A89FA0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 0000022CE1A89FA0
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A89FA0
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A89F00
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Overriding type to i64 for GetField result
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A89F00
DEBUG LLVM: Checking statement 4 kind=1
DEBUG LLVM: Found Call terminator in block 1
DEBUG LLVM: Call has destination place=0000022CE1A89AA0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A89AA0
DEBUG LLVM: Finished processing block 1
DEBUG LLVM: Processing block 2 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 2
DEBUG LLVM: Call has destination place=0000022CE1A8A590
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A8A590
DEBUG LLVM: Finished processing block 2
DEBUG LLVM: Processing block 3 with 5 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A8A680
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 0000022CE1A8A680
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A8A680
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A8A5E0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Overriding type to i64 for GetField result
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A8A5E0
DEBUG LLVM: Checking statement 4 kind=1
DEBUG LLVM: Found Call terminator in block 3
DEBUG LLVM: Call has destination place=0000022CE1A89A00
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A89A00
DEBUG LLVM: Finished processing block 3
DEBUG LLVM: Processing block 4 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 4
DEBUG LLVM: Call has destination place=0000022CE1A8A2C0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A8A2C0
DEBUG LLVM: Finished processing block 4
DEBUG LLVM: Processing block 5 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 5
DEBUG LLVM: Call has destination place=0000022CE1A8A270
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 0000022CE1A8A270
DEBUG LLVM: Finished processing block 5
DEBUG LLVM: Processing block 6 with 1 statements
DEBUG LLVM: Checking statement 0 kind=0
DEBUG LLVM: Found assign statement, place=0000022CE1A7E290
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i32
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 0000022CE1A7E290
DEBUG LLVM: Finished processing block 6
DEBUG LLVM: Finished creating all allocas
DEBUG LLVM: Created basic block bb0 with 6 statements
DEBUG LLVM: Created basic block call_cont with 5 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 5 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created branch from entry to bb0
DEBUG LLVM: Processing block bb0 with 6 statements
DEBUG LLVM: ========== Generating basic block: bb0 ==========
DEBUG LLVM: LLVM BB: %bb0
DEBUG LLVM: Generating 6 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Aggregate rvalue
DEBUG LLVM: generateAggregate called with 2 elements
DEBUG LLVM: Struct aggregate with 2 fields - checking if SetField
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 1
DEBUG LLVM: constOp->type.get() = 0000022CE1A89640
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 0000022CE1A8DAD8
DEBUG LLVM: Field 0 type: i64
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 2
DEBUG LLVM: constOp->type.get() = 0000022CE1A89280
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 0000022CE1A8DAD8
DEBUG LLVM: Field 1 type: i64
DEBUG LLVM: Using heap allocation (malloc) for closure environment
DEBUG LLVM: Allocated 16 bytes on heap for closure environment
DEBUG LLVM: Struct allocated and initialized, returning pointer
DEBUG LLVM: Stored struct type in arrayTypeMap
DEBUG LLVM: RValue converted, value=0000022CE1A99F30
DEBUG LLVM: Looking for alloca for variable 0000022CE1A7EE70
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from value
DEBUG LLVM:   Source value =   %closure_env = call ptr @nova_alloc_closure_env(i64 16)
DEBUG LLVM:   Dest alloca =   %var = alloca ptr, align 8
DEBUG LLVM:   Type = %anon_struct = type { i64, i64 }
DEBUG LLVM:   arrayTypeMap now has 2 entries
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A7EE70 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 0000022CE1A97E60
DEBUG LLVM: RValue converted, value=0000022CE1A97E60
DEBUG LLVM: Looking for alloca for variable 0000022CE1A899B0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 8 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_string
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_string
DEBUG LLVM: Creating external nova_console_log_string declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating string constant: Both:
DEBUG LLVM: Argument converted, argValue = 0000022CE1A97BE0
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 0000022CE1A983A8
DEBUG LLVM: callee name = nova_console_log_string
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %bb0
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 0000022CE1A9AB50
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_string(ptr @.str)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %bb0
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont
DEBUG LLVM: [CRITICAL] Current block before branch: %bb0
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 10 instructions after terminator
DEBUG LLVM: Block bb0 processed
DEBUG LLVM: Processing block call_cont with 5 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont
DEBUG LLVM: Generating 5 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A899B0 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 0000022CE1A965E0
DEBUG LLVM: RValue converted, value=0000022CE1A965E0
DEBUG LLVM: Looking for alloca for variable 0000022CE1A89FA0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
=== Ref rvalue case ===
=== Confirmed GetElement, calling generateGetElement ===

=== generateGetElement CALLED ===
isFieldAccess: 1
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A89FA0 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 0
DEBUG LLVM: constOp->type.get() = 0000022CE1A8ADA0
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 0000022CE1A8DAD8
DEBUG LLVM: arrayPtr type: 15
DEBUG LLVM: Using GEP to access array element
DEBUG LLVM: arrayPtr is a load, getting pointer operand
DEBUG LLVM: Array type determined: %anon_struct = type { i64, i64 }

DEBUG LLVM: loadedArrayPtr type: ptr
DEBUG LLVM: loadedArrayPtr is a LoadInst
DEBUG LLVM: Converted struct field index to i32
DEBUG LLVM: Skipping array metadata check because isFieldAccess=true

=== BEFORE STRUCT FIELD ACCESS CHECK ===
isFieldAccess=1
isMetadataFieldAccess=0
arrayType is StructType: YES
indexValue is ConstantInt: YES
=== STRUCT FIELD ACCESS PATH TAKEN ===
DEBUG LLVM: Accessing regular struct field 0 (actual index 1 accounting for ObjectHeader)
*** GetElement: loading from LLVM index 1
DEBUG LLVM: Loaded struct field 0
DEBUG LLVM: RValue converted, value=0000022CE1A96EE0
DEBUG LLVM: Looking for alloca for variable 0000022CE1A89F00
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 6 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_print_space
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_print_space
DEBUG LLVM: Creating external nova_console_print_space declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 0
DEBUG LLVM: About to create call with 0 arguments
DEBUG LLVM: callee = 0000022CE1A9B5C8
DEBUG LLVM: callee name = nova_console_print_space
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 0000022CE1A97960
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_print_space()
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont12
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont12
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 8 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont12
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_number
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_number
DEBUG LLVM: Creating external nova_console_log_number declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A89F00 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Argument converted, argValue = 0000022CE1A978E0
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 0000022CE1A9B668
DEBUG LLVM: callee name = nova_console_log_number
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont12
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 0000022CE1A9C230
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_number(i64 %load20)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont12
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont13
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont12
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont13
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 3 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 5 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont13
DEBUG LLVM: Generating 5 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A899B0 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 0000022CE1A975E0
DEBUG LLVM: RValue converted, value=0000022CE1A975E0
DEBUG LLVM: Looking for alloca for variable 0000022CE1A8A680
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
=== Ref rvalue case ===
=== Confirmed GetElement, calling generateGetElement ===

=== generateGetElement CALLED ===
isFieldAccess: 1
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 0000022CE1A8A680 in valueMap (size: 13)
DEBUG LLVM: valueMap entry: place=0000022CE1A7EE70, value=0000022CE1A88A90
DEBUG LLVM: valueMap entry: place=0000022CE1A899B0, value=0000022CE1A88790
DEBUG LLVM: valueMap entry: place=0000022CE1A89AA0, value=0000022CE1A88F10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A220, value=0000022CE1A88910
DEBUG LLVM: valueMap entry: place=0000022CE1A89F00, value=0000022CE1A88990
DEBUG LLVM: valueMap entry: place=0000022CE1A89FA0, value=0000022CE1A88890
DEBUG LLVM: valueMap entry: place=0000022CE1A8A590, value=0000022CE1A88A10
DEBUG LLVM: valueMap entry: place=0000022CE1A8A680, value=0000022CE1A88B90
DEBUG LLVM: valueMap entry: place=0000022CE1A8A5E0, value=0000022CE1A88C90
DEBUG LLVM: valueMap entry: place=0000022CE1A89A00, value=0000022CE1A88010
DEBUG LLVM: valueMap entry: place=0000022CE1A8A2C0, value=0000022CE1A96F60
DEBUG LLVM: valueMap entry: place=0000022CE1A8A270, value=0000022CE1A97EE0
DEBUG LLVM: valueMap entry: place=0000022CE1A7E290, value=0000022CE1A97260
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 1
DEBUG LLVM: constOp->type.get() = 0000022CE1A8AB30
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 0000022CE1A8DAD8
DEBUG LLVM: arrayPtr type: 15
DEBUG LLVM: Using GEP to access array element
DEBUG LLVM: arrayPtr is a load, getting pointer operand
DEBUG LLVM: Array type determined: %anon_struct = type { i64, i64 }

DEBUG LLVM: loadedArrayPtr type: ptr
DEBUG LLVM: loadedArrayPtr is a LoadInst
DEBUG LLVM: Converted struct field index to i32
DEBUG LLVM: Skipping array metadata check because isFieldAccess=true

=== BEFORE STRUCT FIELD ACCESS CHECK ===
isFieldAccess=1
isMetadataFieldAccess=0
arrayType is StructType: YES
indexValue is ConstantInt: YES
=== STRUCT FIELD ACCESS PATH TAKEN ===
DEBUG LLVM: Accessing regular struct field 1 (actual index 2 accounting for ObjectHeader)
*** GetElement: loading from LLVM index 2
