// MIR Module: main

fn testBreakInWhile() -> i64 {
    // Local declarations
    let mut _i.0: *const // i.0;
    let mut _t1: bool // t1;
    let mut _t2: bool // t2;
    let mut _t3: *const // t3;

    bb0:
    StorageLive(_i.0);
    StorageLive(_i.0);
    _i.0 = Use(const 0);
    goto -> bb1;

    bb1:
    StorageLive(_t1);
    _t1 = BinaryOp(Lt, copy _i.0, const 10);
    switchInt(copy _t1) {
        1 => bb2,
        otherwise => bb3
    };

    bb2:
    StorageLive(_t2);
    _t2 = BinaryOp(Eq, copy _i.0, const 5);
    switchInt(copy _t2) {
        1 => bb4,
        otherwise => bb5
    };

    bb3:
    _0 = Use(copy _i.0);
    return;

    bb4:
    goto -> bb5;

    bb5:
    _0 = Use(const 0);
    StorageLive(_t3);
    _t3 = BinaryOp(Add, copy _i.0, const 1);
    _i.0 = Use(copy _t3);
    goto -> bb1;

}

fn testContinueInWhile() -> i64 {
    // Local declarations
    let mut _i.0: *const // i.0;
    let mut _sum.1: *const // sum.1;
    let mut _t2: bool // t2;
    let mut _t3: *const // t3;
    let mut _t4: bool // t4;
    let mut _t5: *const // t5;

    bb0:
    StorageLive(_i.0);
    StorageLive(_i.0);
    _i.0 = Use(const 0);
    StorageLive(_sum.1);
    StorageLive(_sum.1);
    _sum.1 = Use(const 0);
    goto -> bb1;

    bb1:
    StorageLive(_t2);
    _t2 = BinaryOp(Lt, copy _i.0, const 5);
    switchInt(copy _t2) {
        1 => bb2,
        otherwise => bb3
    };

    bb2:
    StorageLive(_t3);
    _t3 = BinaryOp(Add, copy _i.0, const 1);
    _i.0 = Use(copy _t3);
    StorageLive(_t4);
    _t4 = BinaryOp(Eq, copy _i.0, const 3);
    switchInt(copy _t4) {
        1 => bb4,
        otherwise => bb5
    };

    bb3:
    _0 = Use(copy _sum.1);
    return;

    bb4:
    goto -> bb5;

    bb5:
    _0 = Use(const 0);
    StorageLive(_t5);
    _t5 = BinaryOp(Add, copy _sum.1, copy _i.0);
    _sum.1 = Use(copy _t5);
    goto -> bb1;

}

fn main() -> i64 {
    // Local declarations
    let mut _t0: i64 // t0;
    let mut _t1: i64 // t1;
    let mut _t2: i64 // t2;

    bb0:
    StorageLive(_t0);
    _t0 = call const "testBreakInWhile"() -> [return: call_cont];

    call_cont:
    StorageLive(_t1);
    _t1 = call const "testContinueInWhile"() -> [return: call_cont];

    call_cont:
    StorageLive(_t2);
    _t2 = BinaryOp(Add, copy _t0, copy _t1);
    _0 = Use(copy _t2);
    return;

}

