Token #1 pos=0 char='c' (ASCII 99)
Token #2 pos=6 char='o' (ASCII 111)
Token #3 pos=10 char='=' (ASCII 61)
Token #4 pos=12 char='{' (ASCII 123)
Token #5 pos=14 char='a' (ASCII 97)
Token #6 pos=15 char=':' (ASCII 58)
Token #7 pos=17 char='1' (ASCII 49)
Token #8 pos=18 char=',' (ASCII 44)
Token #9 pos=20 char='b' (ASCII 98)
Token #10 pos=21 char=':' (ASCII 58)
Token #11 pos=23 char='2' (ASCII 50)
Token #12 pos=25 char='}' (ASCII 125)
Token #13 pos=26 char=';' (ASCII 59)
Token #14 pos=28 char='c' (ASCII 99)
Token #15 pos=35 char='.' (ASCII 46)
Token #16 pos=36 char='l' (ASCII 108)
Token #17 pos=39 char='(' (ASCII 40)
Token #18 pos=40 char='"' (ASCII 34)
Token #19 pos=44 char=',' (ASCII 44)
Token #20 pos=46 char='o' (ASCII 111)
Token #21 pos=49 char='.' (ASCII 46)
Token #22 pos=50 char='a' (ASCII 97)
Token #23 pos=51 char=')' (ASCII 41)
Token #24 pos=52 char=';' (ASCII 59)
Token #25 pos=54 char='c' (ASCII 99)
Token #26 pos=61 char='.' (ASCII 46)
Token #27 pos=62 char='l' (ASCII 108)
Token #28 pos=65 char='(' (ASCII 40)
Token #29 pos=66 char='"' (ASCII 34)
Token #30 pos=70 char=',' (ASCII 44)
Token #31 pos=72 char='o' (ASCII 111)
Token #32 pos=75 char='.' (ASCII 46)
Token #33 pos=76 char='b' (ASCII 98)
Token #34 pos=77 char=')' (ASCII 41)
Token #35 pos=78 char=';' (ASCII 59)

=== TRACE: ObjectExpr processing, ID=__obj_0 ===
  TRACE: Property 'a' is a data field
  TRACE: Property 'b' is a data field
  TRACE: Creating struct type '__obj_0' with 2 data fields
DEBUG HIRGen: Detected console.log() call with 2 arguments
DEBUG HIRGen: console.log arg 0: type=17
DEBUG HIRGen: Selected runtime function: nova_console_log_string (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_string

=== TRACE: MemberExpr property access ===
  Property name: 'a'
  object pointer: 00000199C2C775F0
  currentThis_ pointer: 0000000000000000
  object == currentThis_: NO
  currentClassStructType_: 0000000000000000
  TRACE: Extracting struct type from object->type
  TRACE: object->type pointer: 00000199C2C5DBE0
  TRACE: object->type->kind = 18
  TRACE: Object type is NOT directly a Struct, trying Pointer
  TRACE: HIRPointerType cast result: 00000199C2C5DBE0
  TRACE: Successfully cast to HIRPointerType
  TRACE: Pointee type exists, kind=22
  TRACE: Pointee is a struct!
  TRACE: Struct name: __obj_0
  TRACE: Struct has 2 fields:
    [0] a (kind=6)
    [1] b (kind=6)

  TRACE: Searching for field 'a' in struct...
  TRACE: structType is valid, searching 2 fields
    Checking field[0]: 'a'
  TRACE SUCCESS: Found field 'a' at index 0

  TRACE: Creating GetField operation
    object pointer: 00000199C2C775F0
    field index: 0
    field name: 'a'
  DEBUG GetField: Found field type from pointer-to-struct, type=6
    Result lastValue_: 00000199C2C774F0
    Result type kind: 6
=== END TRACE ===
DEBUG HIRGen: console.log arg 1: type=6
DEBUG HIRGen: Selected runtime function: nova_console_log_number (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_number
DEBUG HIRGen: Detected console.log() call with 2 arguments
DEBUG HIRGen: console.log arg 0: type=17
DEBUG HIRGen: Selected runtime function: nova_console_log_string (needsLoad=0)

=== TRACE: MemberExpr property access ===
  Property name: 'b'
  object pointer: 00000199C2C77B70
  currentThis_ pointer: 0000000000000000
  object == currentThis_: NO
  currentClassStructType_: 0000000000000000
  TRACE: Extracting struct type from object->type
  TRACE: object->type pointer: 00000199C2C5DBE0
  TRACE: object->type->kind = 18
  TRACE: Object type is NOT directly a Struct, trying Pointer
  TRACE: HIRPointerType cast result: 00000199C2C5DBE0
  TRACE: Successfully cast to HIRPointerType
  TRACE: Pointee type exists, kind=22
  TRACE: Pointee is a struct!
  TRACE: Struct name: __obj_0
  TRACE: Struct has 2 fields:
    [0] a (kind=6)
    [1] b (kind=6)

  TRACE: Searching for field 'b' in struct...
  TRACE: structType is valid, searching 2 fields
    Checking field[0]: 'a'
    Checking field[1]: 'b'
  TRACE SUCCESS: Found field 'b' at index 1

  TRACE: Creating GetField operation
    object pointer: 00000199C2C77B70
    field index: 1
    field name: 'b'
  DEBUG GetField: Found field type from pointer-to-struct, type=6
    Result lastValue_: 00000199C2C77C70
    Result type kind: 6
=== END TRACE ===
DEBUG HIRGen: console.log arg 1: type=6
DEBUG HIRGen: Selected runtime function: nova_console_log_number (needsLoad=0)
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77EF0) with 2 operands
  Function: nova_console_log_string
  Operand 0: value present (ptr=00000199C2C74420)
DEBUG MIRGen: Translating string constant: nova_console_log_string
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Translating string constant: a:
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: GetField dest type = 5
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77470) with 1 operands
  Function: nova_console_print_space
DEBUG MIRGen: Translating string constant: nova_console_print_space
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77BF0) with 2 operands
  Function: nova_console_log_number
  Operand 0: value present (ptr=00000199C2C774F0)
DEBUG MIRGen: Translating string constant: nova_console_log_number
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77870) with 1 operands
  Function: nova_console_print_newline
DEBUG MIRGen: Translating string constant: nova_console_print_newline
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C778F0) with 2 operands
  Function: nova_console_log_string
  Operand 0: value present (ptr=00000199C2C74500)
DEBUG MIRGen: Translating string constant: nova_console_log_string
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Translating string constant: b:
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: GetField dest type = 5
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C76FF0) with 1 operands
  Function: nova_console_print_space
DEBUG MIRGen: Translating string constant: nova_console_print_space
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77970) with 2 operands
  Function: nova_console_log_number
  Operand 0: value present (ptr=00000199C2C77C70)
DEBUG MIRGen: Translating string constant: nova_console_log_number
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=00000199C2C77770) with 1 operands
  Function: nova_console_print_newline
DEBUG MIRGen: Translating string constant: nova_console_print_newline
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing return statement in function '__nova_main'
DEBUG MIRGen: Return value cast to constant: SUCCESS

========== MIR DUMP ==========
// MIR Module: main

fn __nova_main() -> i32 {
    // Local declarations
    let mut ___obj_0.0: *const // __obj_0.0;
    let mut _obj.1: *const // obj.1;
    let mut _console_result.2: () // console_result.2;
    let mut _obj.3: *const // obj.3;
    let mut _a.4: i64 // a.4;
    let mut _space.5: () // space.5;
    let mut _console_result.6: () // console_result.6;
    let mut _console_newline.7: () // console_newline.7;
    let mut _console_result.8: () // console_result.8;
    let mut _obj.9: *const // obj.9;
    let mut _b.10: i64 // b.10;
    let mut _space.11: () // space.11;
    let mut _console_result.12: () // console_result.12;
    let mut _console_newline.13: () // console_newline.13;

    bb0:
    StorageLive(___obj_0.0);
    ___obj_0.0 = Aggregate(Struct, [const 1, const 2]);
    StorageLive(_obj.1);
    StorageLive(_obj.1);
    _obj.1 = Use(copy ___obj_0.0);
    StorageLive(_console_result.2);
    _console_result.2 = call const "nova_console_log_string"(const "a:") -> [return: call_cont];

    call_cont:
    StorageLive(_obj.3);
    _obj.3 = Use(copy _obj.1);
    StorageLive(_a.4);
    _a.4 = GetElement(copy _obj.3, const 0);
    StorageLive(_space.5);
    _space.5 = call const "nova_console_print_space"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.6);
    _console_result.6 = call const "nova_console_log_number"(copy _a.4) -> [return: call_cont];

    call_cont:
    StorageLive(_console_newline.7);
    _console_newline.7 = call const "nova_console_print_newline"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.8);
    _console_result.8 = call const "nova_console_log_string"(const "b:") -> [return: call_cont];

    call_cont:
    StorageLive(_obj.9);
    _obj.9 = Use(copy _obj.1);
    StorageLive(_b.10);
    _b.10 = GetElement(copy _obj.9, const 1);
    StorageLive(_space.11);
    _space.11 = call const "nova_console_print_space"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.12);
    _console_result.12 = call const "nova_console_log_number"(copy _b.10) -> [return: call_cont];

    call_cont:
    StorageLive(_console_newline.13);
    _console_newline.13 = call const "nova_console_print_newline"() -> [return: call_cont];

    call_cont:
    _0 = Use(const 0);
    return;

}

========== END MIR DUMP ==========

DEBUG LLVM: Disabling constant folding to preserve runtime comparisons
DEBUG LLVM: First pass - creating function declarations
DEBUG LLVM: Declared function: __nova_main
DEBUG LLVM: Second pass - generating function bodies
DEBUG LLVM: Starting generateFunction for: __nova_main
DEBUG LLVM: Cleared per-function context maps
DEBUG LLVM: Created struct type struct.NovaObject with ObjectHeader + 8 fields
DEBUG LLVM: Using existing declaration for function: __nova_main
DEBUG LLVM: Creating alloca for variables to prevent constant folding
DEBUG LLVM: Function has 9 basic blocks
DEBUG LLVM: Processing block 0 with 6 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C6E100
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 00000199C2C6E100
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C6E100
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=1
DEBUG LLVM: Checking statement 4 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C7B2B0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 00000199C2C7B2B0
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C7B2B0
DEBUG LLVM: Checking statement 5 kind=1
DEBUG LLVM: Found Call terminator in block 0
DEBUG LLVM: Call has destination place=00000199C2C7B940
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7B940
DEBUG LLVM: Finished processing block 0
DEBUG LLVM: Processing block 1 with 5 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C7B580
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 00000199C2C7B580
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C7B580
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C7BBC0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Overriding type to i64 for GetField result
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C7BBC0
DEBUG LLVM: Checking statement 4 kind=1
DEBUG LLVM: Found Call terminator in block 1
DEBUG LLVM: Call has destination place=00000199C2C7B620
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7B620
DEBUG LLVM: Finished processing block 1
DEBUG LLVM: Processing block 2 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 2
DEBUG LLVM: Call has destination place=00000199C2C7BF80
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7BF80
DEBUG LLVM: Finished processing block 2
DEBUG LLVM: Processing block 3 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 3
DEBUG LLVM: Call has destination place=00000199C2C7B9E0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7B9E0
DEBUG LLVM: Finished processing block 3
DEBUG LLVM: Processing block 4 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 4
DEBUG LLVM: Call has destination place=00000199C2C7B8F0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7B8F0
DEBUG LLVM: Finished processing block 4
DEBUG LLVM: Processing block 5 with 5 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C7B8A0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 00000199C2C7B8A0
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C7B8A0
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C7B710
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Overriding type to i64 for GetField result
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C7B710
DEBUG LLVM: Checking statement 4 kind=1
DEBUG LLVM: Found Call terminator in block 5
DEBUG LLVM: Call has destination place=00000199C2C7BEE0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7BEE0
DEBUG LLVM: Finished processing block 5
DEBUG LLVM: Processing block 6 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 6
DEBUG LLVM: Call has destination place=00000199C2C7B990
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7B990
DEBUG LLVM: Finished processing block 6
DEBUG LLVM: Processing block 7 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 7
DEBUG LLVM: Call has destination place=00000199C2C7BA30
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 00000199C2C7BA30
DEBUG LLVM: Finished processing block 7
DEBUG LLVM: Processing block 8 with 1 statements
DEBUG LLVM: Checking statement 0 kind=0
DEBUG LLVM: Found assign statement, place=00000199C2C6EA10
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i32
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 00000199C2C6EA10
DEBUG LLVM: Finished processing block 8
DEBUG LLVM: Finished creating all allocas
DEBUG LLVM: Created basic block bb0 with 6 statements
DEBUG LLVM: Created basic block call_cont with 5 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 5 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created branch from entry to bb0
DEBUG LLVM: Processing block bb0 with 6 statements
DEBUG LLVM: ========== Generating basic block: bb0 ==========
DEBUG LLVM: LLVM BB: %bb0
DEBUG LLVM: Generating 6 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Aggregate rvalue
DEBUG LLVM: generateAggregate called with 2 elements
DEBUG LLVM: Struct aggregate with 2 fields - checking if SetField
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 1
DEBUG LLVM: constOp->type.get() = 00000199C2C7AF10
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 00000199C2C80738
DEBUG LLVM: Field 0 type: i64
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 2
DEBUG LLVM: constOp->type.get() = 00000199C2C7ADC0
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 00000199C2C80738
DEBUG LLVM: Field 1 type: i64
DEBUG LLVM: Using heap allocation (malloc) for closure environment
DEBUG LLVM: Allocated 16 bytes on heap for closure environment
DEBUG LLVM: Struct allocated and initialized, returning pointer
DEBUG LLVM: Stored struct type in arrayTypeMap
DEBUG LLVM: RValue converted, value=00000199C2C88FF0
DEBUG LLVM: Looking for alloca for variable 00000199C2C6E100
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from value
DEBUG LLVM:   Source value =   %closure_env = call ptr @nova_alloc_closure_env(i64 16)
DEBUG LLVM:   Dest alloca =   %var = alloca ptr, align 8
DEBUG LLVM:   Type = %anon_struct = type { i64, i64 }
DEBUG LLVM:   arrayTypeMap now has 2 entries
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C6E100 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 00000199C2C87440
DEBUG LLVM: RValue converted, value=00000199C2C87440
DEBUG LLVM: Looking for alloca for variable 00000199C2C7B2B0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 8 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_string
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_string
DEBUG LLVM: Creating external nova_console_log_string declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating string constant: a:
DEBUG LLVM: Argument converted, argValue = 00000199C2C87940
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 00000199C2C8A828
DEBUG LLVM: callee name = nova_console_log_string
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %bb0
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 00000199C2C8B9F0
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_string(ptr @.str)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %bb0
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont
DEBUG LLVM: [CRITICAL] Current block before branch: %bb0
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 10 instructions after terminator
DEBUG LLVM: Block bb0 processed
DEBUG LLVM: Processing block call_cont with 5 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont
DEBUG LLVM: Generating 5 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C7B2B0 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 00000199C2C86A40
DEBUG LLVM: RValue converted, value=00000199C2C86A40
DEBUG LLVM: Looking for alloca for variable 00000199C2C7B580
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
=== Ref rvalue case ===
=== Confirmed GetElement, calling generateGetElement ===

=== generateGetElement CALLED ===
isFieldAccess: 1
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C7B580 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 0
DEBUG LLVM: constOp->type.get() = 00000199C2C7AA90
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 00000199C2C80738
DEBUG LLVM: arrayPtr type: 15
DEBUG LLVM: Using GEP to access array element
DEBUG LLVM: arrayPtr is a load, getting pointer operand
DEBUG LLVM: Array type determined: %anon_struct = type { i64, i64 }

DEBUG LLVM: loadedArrayPtr type: ptr
DEBUG LLVM: loadedArrayPtr is a LoadInst
DEBUG LLVM: Converted struct field index to i32
DEBUG LLVM: Skipping array metadata check because isFieldAccess=true

=== BEFORE STRUCT FIELD ACCESS CHECK ===
isFieldAccess=1
isMetadataFieldAccess=0
arrayType is StructType: YES
indexValue is ConstantInt: YES
=== STRUCT FIELD ACCESS PATH TAKEN ===
DEBUG LLVM: Accessing regular struct field 0 (actual index 1 accounting for ObjectHeader)
*** GetElement: loading from LLVM index 1
DEBUG LLVM: Loaded struct field 0
DEBUG LLVM: RValue converted, value=00000199C2C87CC0
DEBUG LLVM: Looking for alloca for variable 00000199C2C7BBC0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 6 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_print_space
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_print_space
DEBUG LLVM: Creating external nova_console_print_space declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 0
DEBUG LLVM: About to create call with 0 arguments
DEBUG LLVM: callee = 00000199C2C8BC58
DEBUG LLVM: callee name = nova_console_print_space
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 00000199C2C87C40
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_print_space()
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont14
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont14
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 8 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont14
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_number
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_number
DEBUG LLVM: Creating external nova_console_log_number declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C7BBC0 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Argument converted, argValue = 00000199C2C86C40
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 00000199C2C8BCF8
DEBUG LLVM: callee name = nova_console_log_number
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont14
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 00000199C2C8C320
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_number(i64 %load24)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont14
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont15
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont14
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont15
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 3 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont15
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_print_newline
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_print_newline
DEBUG LLVM: Creating external nova_console_print_newline declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 0
DEBUG LLVM: About to create call with 0 arguments
DEBUG LLVM: callee = 00000199C2C8C6A8
DEBUG LLVM: callee name = nova_console_print_newline
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont15
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 00000199C2C861C0
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_print_newline()
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont15
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont16
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont15
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont16
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 2 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont16
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_string
DEBUG LLVM: Tried module->getFunction, result: 00000199C2C8A828
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=00000199C2C8A828, funcName=nova_console_log_string
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating string constant: b:
DEBUG LLVM: Argument converted, argValue = 00000199C2C86D40
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 00000199C2C8A828
DEBUG LLVM: callee name = nova_console_log_string
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont16
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 00000199C2C8C500
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_string(ptr @.str.1)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont16
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont17
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont16
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont17
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 2 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 5 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont17
DEBUG LLVM: Generating 5 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C7B2B0 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 00000199C2C874C0
DEBUG LLVM: RValue converted, value=00000199C2C874C0
DEBUG LLVM: Looking for alloca for variable 00000199C2C7B8A0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
=== Ref rvalue case ===
=== Confirmed GetElement, calling generateGetElement ===

=== generateGetElement CALLED ===
isFieldAccess: 1
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 00000199C2C7B8A0 in valueMap (size: 15)
DEBUG LLVM: valueMap entry: place=00000199C2C7B620, value=00000199C2C77300
DEBUG LLVM: valueMap entry: place=00000199C2C6E100, value=00000199C2C77100
DEBUG LLVM: valueMap entry: place=00000199C2C7B2B0, value=00000199C2C77200
DEBUG LLVM: valueMap entry: place=00000199C2C7B9E0, value=00000199C2C87840
DEBUG LLVM: valueMap entry: place=00000199C2C7B940, value=00000199C2C77280
DEBUG LLVM: valueMap entry: place=00000199C2C6EA10, value=00000199C2C87A40
DEBUG LLVM: valueMap entry: place=00000199C2C7B580, value=00000199C2C77A80
DEBUG LLVM: valueMap entry: place=00000199C2C7BBC0, value=00000199C2C77B00
DEBUG LLVM: valueMap entry: place=00000199C2C7BF80, value=00000199C2C85F40
DEBUG LLVM: valueMap entry: place=00000199C2C7B8F0, value=00000199C2C86FC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B8A0, value=00000199C2C86BC0
DEBUG LLVM: valueMap entry: place=00000199C2C7B710, value=00000199C2C87640
DEBUG LLVM: valueMap entry: place=00000199C2C7BEE0, value=00000199C2C871C0
DEBUG LLVM: valueMap entry: place=00000199C2C7B990, value=00000199C2C86740
DEBUG LLVM: valueMap entry: place=00000199C2C7BA30, value=00000199C2C876C0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 1
DEBUG LLVM: constOp->type.get() = 00000199C2C7C130
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 00000199C2C80738
DEBUG LLVM: arrayPtr type: 15
DEBUG LLVM: Using GEP to access array element
DEBUG LLVM: arrayPtr is a load, getting pointer operand
DEBUG LLVM: Array type determined: %anon_struct = type { i64, i64 }

DEBUG LLVM: loadedArrayPtr type: ptr
DEBUG LLVM: loadedArrayPtr is a LoadInst
DEBUG LLVM: Converted struct field index to i32
DEBUG LLVM: Skipping array metadata check because isFieldAccess=true

=== BEFORE STRUCT FIELD ACCESS CHECK ===
isFieldAccess=1
isMetadataFieldAccess=0
arrayType is StructType: YES
indexValue is ConstantInt: YES
=== STRUCT FIELD ACCESS PATH TAKEN ===
DEBUG LLVM: Accessing regular struct field 1 (actual index 2 accounting for ObjectHeader)
*** GetElement: loading from LLVM index 2
