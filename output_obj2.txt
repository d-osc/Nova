Token #1 pos=0 char='c' (ASCII 99)
Token #2 pos=6 char='o' (ASCII 111)
Token #3 pos=10 char='=' (ASCII 61)
Token #4 pos=12 char='{' (ASCII 123)
Token #5 pos=14 char='a' (ASCII 97)
Token #6 pos=15 char=':' (ASCII 58)
Token #7 pos=17 char='1' (ASCII 49)
Token #8 pos=18 char=',' (ASCII 44)
Token #9 pos=20 char='b' (ASCII 98)
Token #10 pos=21 char=':' (ASCII 58)
Token #11 pos=23 char='2' (ASCII 50)
Token #12 pos=25 char='}' (ASCII 125)
Token #13 pos=26 char=';' (ASCII 59)
Token #14 pos=28 char='c' (ASCII 99)
Token #15 pos=34 char='v' (ASCII 118)
Token #16 pos=38 char='=' (ASCII 61)
Token #17 pos=40 char='o' (ASCII 111)
Token #18 pos=43 char='.' (ASCII 46)
Token #19 pos=44 char='a' (ASCII 97)
Token #20 pos=45 char=';' (ASCII 59)
Token #21 pos=47 char='c' (ASCII 99)
Token #22 pos=54 char='.' (ASCII 46)
Token #23 pos=55 char='l' (ASCII 108)
Token #24 pos=58 char='(' (ASCII 40)
Token #25 pos=59 char='"' (ASCII 34)
Token #26 pos=67 char=',' (ASCII 44)
Token #27 pos=69 char='v' (ASCII 118)
Token #28 pos=72 char=')' (ASCII 41)
Token #29 pos=73 char=';' (ASCII 59)

=== TRACE: ObjectExpr processing, ID=__obj_0 ===
  TRACE: Property 'a' is a data field
  TRACE: Property 'b' is a data field
  TRACE: Creating struct type '__obj_0' with 2 data fields

=== TRACE: MemberExpr property access ===
  Property name: 'a'
  object pointer: 000001A3913F6640
  currentThis_ pointer: 0000000000000000
  object == currentThis_: NO
  currentClassStructType_: 0000000000000000
  TRACE: Extracting struct type from object->type
  TRACE: object->type pointer: 000001A3913DC2F0
  TRACE: object->type->kind = 18
  TRACE: Object type is NOT directly a Struct, trying Pointer
  TRACE: HIRPointerType cast result: 000001A3913DC2F0
  TRACE: Successfully cast to HIRPointerType
  TRACE: Pointee type exists, kind=22
  TRACE: Pointee is a struct!
  TRACE: Struct name: __obj_0
  TRACE: Struct has 2 fields:
    [0] a (kind=6)
    [1] b (kind=6)

  TRACE: Searching for field 'a' in struct...
  TRACE: structType is valid, searching 2 fields
    Checking field[0]: 'a'
  TRACE SUCCESS: Found field 'a' at index 0

  TRACE: Creating GetField operation
    object pointer: 000001A3913F6640
    field index: 0
    field name: 'a'
  DEBUG GetField: Found field type from pointer-to-struct, type=6
    Result lastValue_: 000001A3913F64C0
    Result type kind: 6
=== END TRACE ===
DEBUG HIRGen: Detected console.log() call with 2 arguments
DEBUG HIRGen: console.log arg 0: type=17
DEBUG HIRGen: Selected runtime function: nova_console_log_string (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_string
DEBUG HIRGen: console.log arg 1: type=6
DEBUG HIRGen: Selected runtime function: nova_console_log_number (needsLoad=0)
DEBUG HIRGen: Created external function: nova_console_log_number
DEBUG MIRGen: GetField dest type = 5
DEBUG MIRGen: Processing HIR Call instruction (ptr=000001A3913F6540) with 2 operands
  Function: nova_console_log_string
  Operand 0: value present (ptr=000001A3913F1D90)
DEBUG MIRGen: Translating string constant: nova_console_log_string
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Translating string constant: Value:
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=000001A3913F69C0) with 1 operands
  Function: nova_console_print_space
DEBUG MIRGen: Translating string constant: nova_console_print_space
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=000001A3913F6240) with 2 operands
  Function: nova_console_log_number
  Operand 0: value present (ptr=000001A3913F6BC0)
DEBUG MIRGen: Translating string constant: nova_console_log_number
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Translating argument 0
DEBUG MIRGen: Collected 1 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing HIR Call instruction (ptr=000001A3913F6740) with 1 operands
  Function: nova_console_print_newline
DEBUG MIRGen: Translating string constant: nova_console_print_newline
DEBUG MIRGen: Function operand is not a Copy (probably a constant)
DEBUG MIRGen: Normal function call (not a closure)
DEBUG MIRGen: Collected 0 arguments
DEBUG MIRGen: Creating MIR Call terminator
DEBUG MIRGen: MIR Call created successfully
DEBUG MIRGen: Processing return statement in function '__nova_main'
DEBUG MIRGen: Return value cast to constant: SUCCESS

========== MIR DUMP ==========
// MIR Module: main

fn __nova_main() -> i32 {
    // Local declarations
    let mut ___obj_0.0: *const // __obj_0.0;
    let mut _obj.1: *const // obj.1;
    let mut _obj.2: *const // obj.2;
    let mut _a.3: i64 // a.3;
    let mut _val.4: i64 // val.4;
    let mut _console_result.5: () // console_result.5;
    let mut _val.6: i64 // val.6;
    let mut _space.7: () // space.7;
    let mut _console_result.8: () // console_result.8;
    let mut _console_newline.9: () // console_newline.9;

    bb0:
    StorageLive(___obj_0.0);
    ___obj_0.0 = Aggregate(Struct, [const 1, const 2]);
    StorageLive(_obj.1);
    StorageLive(_obj.1);
    _obj.1 = Use(copy ___obj_0.0);
    StorageLive(_obj.2);
    _obj.2 = Use(copy _obj.1);
    StorageLive(_a.3);
    _a.3 = GetElement(copy _obj.2, const 0);
    StorageLive(_val.4);
    StorageLive(_val.4);
    _val.4 = Use(copy _a.3);
    StorageLive(_console_result.5);
    _console_result.5 = call const "nova_console_log_string"(const "Value:") -> [return: call_cont];

    call_cont:
    StorageLive(_val.6);
    _val.6 = Use(copy _val.4);
    StorageLive(_space.7);
    _space.7 = call const "nova_console_print_space"() -> [return: call_cont];

    call_cont:
    StorageLive(_console_result.8);
    _console_result.8 = call const "nova_console_log_number"(copy _val.6) -> [return: call_cont];

    call_cont:
    StorageLive(_console_newline.9);
    _console_newline.9 = call const "nova_console_print_newline"() -> [return: call_cont];

    call_cont:
    _0 = Use(const 0);
    return;

}

========== END MIR DUMP ==========

DEBUG LLVM: Disabling constant folding to preserve runtime comparisons
DEBUG LLVM: First pass - creating function declarations
DEBUG LLVM: Declared function: __nova_main
DEBUG LLVM: Second pass - generating function bodies
DEBUG LLVM: Starting generateFunction for: __nova_main
DEBUG LLVM: Cleared per-function context maps
DEBUG LLVM: Created struct type struct.NovaObject with ObjectHeader + 8 fields
DEBUG LLVM: Using existing declaration for function: __nova_main
DEBUG LLVM: Creating alloca for variables to prevent constant folding
DEBUG LLVM: Function has 5 basic blocks
DEBUG LLVM: Processing block 0 with 13 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913EDB70
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 000001A3913EDB70
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913EDB70
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Checking statement 3 kind=1
DEBUG LLVM: Checking statement 4 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913F8D40
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 000001A3913F8D40
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913F8D40
DEBUG LLVM: Checking statement 5 kind=1
DEBUG LLVM: Checking statement 6 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913F8480
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=ptr
DEBUG LLVM: WARNING - Creating alloca for pointer type variable 000001A3913F8480
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913F8480
DEBUG LLVM: Checking statement 7 kind=1
DEBUG LLVM: Checking statement 8 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913F8660
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Overriding type to i64 for GetField result
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913F8660
DEBUG LLVM: Checking statement 9 kind=1
DEBUG LLVM: Checking statement 10 kind=1
DEBUG LLVM: Checking statement 11 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913F8AC0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913F8AC0
DEBUG LLVM: Checking statement 12 kind=1
DEBUG LLVM: Found Call terminator in block 0
DEBUG LLVM: Call has destination place=000001A3913F8570
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 000001A3913F8570
DEBUG LLVM: Finished processing block 0
DEBUG LLVM: Processing block 1 with 3 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Checking statement 1 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913F8610
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i64
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913F8610
DEBUG LLVM: Checking statement 2 kind=1
DEBUG LLVM: Found Call terminator in block 1
DEBUG LLVM: Call has destination place=000001A3913F86B0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 000001A3913F86B0
DEBUG LLVM: Finished processing block 1
DEBUG LLVM: Processing block 2 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 2
DEBUG LLVM: Call has destination place=000001A3913F8DE0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 000001A3913F8DE0
DEBUG LLVM: Finished processing block 2
DEBUG LLVM: Processing block 3 with 1 statements
DEBUG LLVM: Checking statement 0 kind=1
DEBUG LLVM: Found Call terminator in block 3
DEBUG LLVM: Call has destination place=000001A3913F8CA0
DEBUG LLVM: Call destination is void, using i64
DEBUG LLVM: Creating alloca for Call destination...
DEBUG LLVM: Created alloca for Call destination 000001A3913F8CA0
DEBUG LLVM: Finished processing block 3
DEBUG LLVM: Processing block 4 with 1 statements
DEBUG LLVM: Checking statement 0 kind=0
DEBUG LLVM: Found assign statement, place=000001A3913EDDF0
DEBUG LLVM: Converting type for place...
DEBUG LLVM: Type converted successfully, type=i32
DEBUG LLVM: Creating alloca instruction...
DEBUG LLVM: Alloca created, adding to valueMap...
DEBUG LLVM: Created alloca for variable 000001A3913EDDF0
DEBUG LLVM: Finished processing block 4
DEBUG LLVM: Finished creating all allocas
DEBUG LLVM: Created basic block bb0 with 13 statements
DEBUG LLVM: Created basic block call_cont with 3 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created basic block call_cont with 1 statements
DEBUG LLVM: Created branch from entry to bb0
DEBUG LLVM: Processing block bb0 with 13 statements
DEBUG LLVM: ========== Generating basic block: bb0 ==========
DEBUG LLVM: LLVM BB: %bb0
DEBUG LLVM: Generating 13 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Aggregate rvalue
DEBUG LLVM: generateAggregate called with 2 elements
DEBUG LLVM: Struct aggregate with 2 fields - checking if SetField
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 1
DEBUG LLVM: constOp->type.get() = 000001A3913F7890
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 000001A3913FB928
DEBUG LLVM: Field 0 type: i64
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 2
DEBUG LLVM: constOp->type.get() = 000001A3913F78C0
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 000001A3913FB928
DEBUG LLVM: Field 1 type: i64
DEBUG LLVM: Using heap allocation (malloc) for closure environment
DEBUG LLVM: Allocated 16 bytes on heap for closure environment
DEBUG LLVM: Struct allocated and initialized, returning pointer
DEBUG LLVM: Stored struct type in arrayTypeMap
DEBUG LLVM: RValue converted, value=000001A3913FFBF0
DEBUG LLVM: Looking for alloca for variable 000001A3913EDB70
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from value
DEBUG LLVM:   Source value =   %closure_env = call ptr @nova_alloc_closure_env(i64 16)
DEBUG LLVM:   Dest alloca =   %var = alloca ptr, align 8
DEBUG LLVM:   Type = %anon_struct = type { i64, i64 }
DEBUG LLVM:   arrayTypeMap now has 2 entries
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913EDB70 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 000001A3913F6350
DEBUG LLVM: RValue converted, value=000001A3913F6350
DEBUG LLVM: Looking for alloca for variable 000001A3913F8D40
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913F8D40 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 000001A3913F6AD0
DEBUG LLVM: RValue converted, value=000001A3913F6AD0
DEBUG LLVM: Looking for alloca for variable 000001A3913F8480
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Propagated array type to variable alloca from source
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
=== Ref rvalue case ===
=== Confirmed GetElement, calling generateGetElement ===

=== generateGetElement CALLED ===
isFieldAccess: 1
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913F8480 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 0
DEBUG LLVM: constOp->type.get() = 000001A3913F7B90
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 000001A3913FB928
DEBUG LLVM: arrayPtr type: 15
DEBUG LLVM: Using GEP to access array element
DEBUG LLVM: arrayPtr is a load, getting pointer operand
DEBUG LLVM: Array type determined: %anon_struct = type { i64, i64 }

DEBUG LLVM: loadedArrayPtr type: ptr
DEBUG LLVM: loadedArrayPtr is a LoadInst
DEBUG LLVM: Converted struct field index to i32
DEBUG LLVM: Skipping array metadata check because isFieldAccess=true

=== BEFORE STRUCT FIELD ACCESS CHECK ===
isFieldAccess=1
isMetadataFieldAccess=0
arrayType is StructType: YES
indexValue is ConstantInt: YES
=== STRUCT FIELD ACCESS PATH TAKEN ===
DEBUG LLVM: Accessing regular struct field 0 (actual index 1 accounting for ObjectHeader)
*** GetElement: loading from LLVM index 1
DEBUG LLVM: Loaded struct field 0
DEBUG LLVM: RValue converted, value=000001A3914060C0
DEBUG LLVM: Looking for alloca for variable 000001A3913F8660
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913F8660 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 000001A3914073C0
DEBUG LLVM: RValue converted, value=000001A3914073C0
DEBUG LLVM: Looking for alloca for variable 000001A3913F8AC0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 16 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_string
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_string
DEBUG LLVM: Creating external nova_console_log_string declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating string constant: Value:
DEBUG LLVM: Argument converted, argValue = 000001A391406B40
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 000001A3914081C8
DEBUG LLVM: callee name = nova_console_log_string
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %bb0
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 000001A391408380
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_string(ptr @.str)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %bb0
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont
DEBUG LLVM: [CRITICAL] Current block before branch: %bb0
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 18 instructions after terminator
DEBUG LLVM: Block bb0 processed
DEBUG LLVM: Processing block call_cont with 3 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont
DEBUG LLVM: Generating 3 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913F8AC0 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Use operand converted to value: 000001A391406FC0
DEBUG LLVM: RValue converted, value=000001A391406FC0
DEBUG LLVM: Looking for alloca for variable 000001A3913F8610
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 2 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_print_space
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_print_space
DEBUG LLVM: Creating external nova_console_print_space declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 0
DEBUG LLVM: About to create call with 0 arguments
DEBUG LLVM: callee = 000001A391408ED8
DEBUG LLVM: callee name = nova_console_print_space
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 000001A3914074C0
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_print_space()
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont10
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont10
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 4 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont10
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_log_number
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_log_number
DEBUG LLVM: Creating external nova_console_log_number declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 1
DEBUG LLVM: Processing argument 0
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Copy operand
DEBUG LLVM: Looking for place 000001A3913F8610 in valueMap (size: 11)
DEBUG LLVM: valueMap entry: place=000001A3913EDB70, value=000001A3913F6E50
DEBUG LLVM: valueMap entry: place=000001A3913F8570, value=000001A3913F6A50
DEBUG LLVM: valueMap entry: place=000001A3913F8D40, value=000001A3913F60D0
DEBUG LLVM: valueMap entry: place=000001A3913F8480, value=000001A3913F6850
DEBUG LLVM: valueMap entry: place=000001A3913F86B0, value=000001A3913F6950
DEBUG LLVM: valueMap entry: place=000001A3913F8610, value=000001A3913F6150
DEBUG LLVM: valueMap entry: place=000001A3913F8660, value=000001A3913F6F50
DEBUG LLVM: valueMap entry: place=000001A3913F8AC0, value=000001A3913F68D0
DEBUG LLVM: valueMap entry: place=000001A3913F8DE0, value=000001A3913F61D0
DEBUG LLVM: valueMap entry: place=000001A3913F8CA0, value=000001A3913F6B50
DEBUG LLVM: valueMap entry: place=000001A3913EDDF0, value=000001A3913F62D0
DEBUG LLVM: Found place in valueMap
DEBUG LLVM: Loading from alloca
DEBUG LLVM: Argument converted, argValue = 000001A391406DC0
DEBUG LLVM: About to create call with 1 arguments
DEBUG LLVM: callee = 000001A391409298
DEBUG LLVM: callee name = nova_console_log_number
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont10
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 000001A391408AB0
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_log_number(i64 %load18)
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont10
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont11
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont10
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont11
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 3 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont11
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Statements generated
DEBUG LLVM: WARNING - Basic block is empty after statement generation
DEBUG LLVM: Added dummy instruction to empty block
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Processing Call terminator
DEBUG LLVM: Call func operand kind: 2
DEBUG LLVM: func operand IS a const operand, constKind: 3
DEBUG LLVM: Looking for function: nova_console_print_newline
DEBUG LLVM: Tried module->getFunction, result: 0000000000000000
[FORCE DEBUG] After module->getFunction, before if chain
DEBUG LLVM: About to check if chain for external declarations, callee=0000000000000000, funcName=nova_console_print_newline
DEBUG LLVM: Creating external nova_console_print_newline declaration
DEBUG LLVM: Have callee, processing arguments...
DEBUG LLVM: callTerm->args.size() = 0
DEBUG LLVM: About to create call with 0 arguments
DEBUG LLVM: callee = 000001A391409158
DEBUG LLVM: callee name = nova_console_print_newline
DEBUG LLVM: [CRITICAL] Current insert block BEFORE CreateCall: %call_cont11
DEBUG LLVM: [CRITICAL] CreateCall succeeded, result = 000001A391405EC0
DEBUG LLVM: [CRITICAL] LLVM IR of call instruction:
  call void @nova_console_print_newline()
DEBUG LLVM: [CRITICAL] Current insert block AFTER CreateCall: %call_cont11
DEBUG LLVM: Checking for malloc in constructor...
DEBUG LLVM: Got constOp
DEBUG LLVM: Storing result in destination...
DEBUG LLVM: Result type is void: 1
DEBUG LLVM: Result storage completed
DEBUG LLVM: About to create branch to target
DEBUG LLVM: [CRITICAL] Target block: %call_cont12
DEBUG LLVM: [CRITICAL] Current block before branch: %call_cont11
DEBUG LLVM: Branch created successfully
DEBUG LLVM: [CRITICAL] LLVM IR of branch instruction:
  br label %call_cont12
DEBUG LLVM: Call terminator processing complete
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 2 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Processing block call_cont with 1 statements
DEBUG LLVM: ========== Generating basic block: call_cont ==========
DEBUG LLVM: LLVM BB: %call_cont12
DEBUG LLVM: Generating 1 statements
DEBUG LLVM: generateStatement called
DEBUG LLVM: Generating assign statement
DEBUG LLVM: Converting rvalue
DEBUG LLVM: convertRValue called
DEBUG LLVM: Processing Use rvalue
DEBUG LLVM: Converting use operand
DEBUG LLVM: convertOperand called
DEBUG LLVM: Processing Constant operand
DEBUG LLVM: Creating int constant: 0
DEBUG LLVM: constOp->type.get() = 000001A3913F9620
DEBUG LLVM: About to call convertType
DEBUG LLVM: convertType returned: 000001A3913FB928
DEBUG LLVM: Use operand converted to value: 000001A391404010
DEBUG LLVM: RValue converted, value=000001A391404010
DEBUG LLVM: Looking for alloca for variable 000001A3913EDDF0
DEBUG LLVM: Storing value in alloca
DEBUG LLVM: Type mismatch detected!
DEBUG LLVM:   Alloca type: i32
DEBUG LLVM:   Value type: i64
DEBUG LLVM: Created new alloca with correct type
DEBUG LLVM: Statements generated
DEBUG LLVM: Basic block has 1 instructions
DEBUG LLVM: Generating terminator
DEBUG LLVM: generateTerminator called
DEBUG LLVM: Generating return terminator
DEBUG LLVM: Terminator generated
DEBUG LLVM: Basic block now has 2 instructions after terminator
DEBUG LLVM: Block call_cont processed
DEBUG LLVM: Basic optimization passes are enabled
DEBUG LLVM: runOptimizationPasses called with optLevel=2
DEBUG LLVM: Creating function pass manager
DEBUG LLVM: Adding basic optimization passes (optLevel >= 1)
DEBUG LLVM: Added LoopRotatePass
DEBUG LLVM: Added LICM (Loop Invariant Code Motion)
DEBUG LLVM: Added CFGSimplificationPass for basic optimizations
DEBUG LLVM: Adding intermediate optimization passes (optLevel >= 2)
DEBUG LLVM: Loop optimizations enabled at level 2
DEBUG LLVM: Added DeadCodeEliminationPass and CFGSimplificationPass
DEBUG LLVM: Initializing function pass manager
DEBUG LLVM: Running optimization passes on functions
DEBUG LLVM: Running passes on function: __nova_main
DEBUG LLVM: Running passes on function: main
DEBUG LLVM: Optimization passes completed
DEBUG LLVM: emitExecutable called for .nova-cache/bin/3a289f460d05a9ca.exe
DEBUG LLVM: emitLLVMIR ENTRY POINT - filename=.nova-cache/bin/3a289f460d05a9ca.exe.ll
DEBUG LLVM: emitLLVMIR called - Module has 8 functions
DEBUG LLVM: emitLLVMIR - Function printf has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function __nova_main has 1 basic blocks
DEBUG LLVM: emitLLVMIR - Basic block entry has 9 instructions
DEBUG LLVM: emitLLVMIR - Function nova_alloc_closure_env has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function nova_console_log_string has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function nova_console_print_space has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function nova_console_log_number has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function nova_console_print_newline has 0 basic blocks
DEBUG LLVM: emitLLVMIR - Function main has 1 basic blocks
DEBUG LLVM: emitLLVMIR - Basic block entry has 2 instructions
DEBUG: Raw LLVM IR dumped to debug_output.ll
DEBUG LLVM: Looking for novacore.lib at: C:\Users\ondev\Projects\Nova\build\Release/novacore.lib
DEBUG LLVM: novacore.lib exists: yes
DEBUG LLVM: Compile command: clang++ -O0 ".nova-cache/bin/3a289f460d05a9ca.exe.ll" "C:\Users\ondev\Projects\Nova\build\Release/novacore.lib" -o ".nova-cache/bin/3a289f460d05a9ca.exe" -lmsvcrt -lkernel32 -lWs2_32 -lAdvapi32 -Wno-override-module 2>&1
novacore.lib(ClosureEnv.obj) : MSIL .netmodule or module compiled with /GL found; restarting link with /LTCG; add /LTCG to the link command line to improve linker performance
LINK : warning LNK4098: defaultlib 'libcmt' conflicts with use of other libs; use /NODEFAULTLIB:library
Generating code
Finished generating code
DEBUG LLVM: Successfully created executable: .nova-cache/bin/3a289f460d05a9ca.exe
Value: 2

